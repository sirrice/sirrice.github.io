---
layout: post
color: '#0c6a99'
title: "How to Write an Introduction"
date: 2024-11-30
categories: [writing]
tags: [writing]
---


Writing academic papers is hard, and writing introductions is very hard.
While there are [many tips and articles](https://github.com/researchsetup/researchsetup.github.io/wiki/communication#writing)
for how to improve writing, they are typically tactical in nature.   They explain how to present citations, or connect sentences, or use "While" instead of "But".   But they do not explain how to plan a project for success, nor how to approach the process of describing the paper.

This post presents a mental model of writing an introduction (and consequently the paper) is, so that you can think strategically about not only the writing process, but also the project itself.   This is in the context of writing database systems papers, but should apply broadly.


## The Model

The fundamental constraint of writing is that it is linear.   Your goal is to write a linear sequence of words and sentences to convey that your project is novel and better (than prior work).  The reason why this is hard is because your project is _not linear_ but actually a complex dependency graph between necessary concepts (nodes) and their motivation (edges).   Knowing the structure of this graph will help you plan your project.  A simple linear ordering of the nodes in this graph is sufficient to write a well-structured introduction (and paper!).   This model works because my papers that follow the model are accepted, and the reason for a paper rejection can be traced to missing or unclear descriptions of some node.

![image]({{ "/files/images/blog/paper_model.png" | relative_url}})

I have numbered the nodes in the typical order that they are presented in an introduction, and colored them according to their role.  Let us examine them roughly in numeric order.  For an example, see the first paragraph of this section. 

Every paper is centered around a **problem** in the current literature.  The problem is only important because of the **use cases** that encounter this problem.  These may be use cases today (applied research), in 5 years (forward-looking research), or perhaps never (speculative research).  The bigger, more relevant, more pressing, more broad reaching, the better.   But you need to make sure that the problem is _the most important issue_ for the use case - _"the high pole in the tent"_ as Turing laureate [Stonebraker](https://en.wikipedia.org/wiki/Michael_Stonebraker) likes to say.

Now, the problem only exists because of a set of **causes** (in the [causal](https://en.wikipedia.org/wiki/Causal_reasoning) sense).   Can you identify what they are?  The closer to the root cause of the problem, the better.  You can tell because the presence of the cause leads to the problem, and making the cause disappear remove the problem.   Naturally, identifying the cause implies a strategy to fix the cause.  This strategy is called **the insight**, which is what motivates the **technical solution(s)**.

How do we know fixing the cause solved the problem?   Well, we need some **metric** to measure success.   In an established problem, there are usually agreed upon metrics (whether you agree with them or not), but in new problems you may need to justify a metric based on logical reasoning.   These, along with the solutions, motivate an experimental design that can attribute better outcomes to the solution, and ideally to the root cause.

## Implications of this Model

As you can see, there are two "source nodes" in the graph, the use case and the cause, that represent the main degrees of freedom that you as a researcher have: to choose the problem and to pick the cause(s) to fix.  In a sense, everything else is simply a logical consequence (which may require creativity).   The solution is an ancillary degree of freedom, because you are free to choose between the many imperfect or perfect ways to fix the root cause.

This is a dependency graph.  What this means is that changing one node may require adjusting all of the other nodes in response.  Say you change your solution.  It may not be solving your original cause anymore, but instead a slightly different cause, which solves a slightly different problem, which is no longer important for the use cases and does not justify the metric of success, which means you need to re-design your experiments.   

People usually think of novelty as a different solution to the same problem.  From the graph, it is clear that this is a shallow form of novelty.   It is really characterized by novelty upstream of the solution: a novel insight that leads to this new solution, or even better, a cause that is even more of a "root cause".   

Related work is based on a partial matching problem between all existing papers and your paper.  It is partial because you may match on any subset of nodes, but typically some combination of **Problem**, **Cause**,  **Insight**, and/or **Solution**.   Since related work is of finite length, this is a top-k partial matching.   Once you have aligned on a subset of nodes, your job is to explain the alignment __and the difference__ between the unaligned nodes.   


## Additional Examples

I will use some recent papers from my lab as additional examples.

#### 




## Related Work


